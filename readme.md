# 
actually our browsers have javascript engine by default
but to run react we use cdn links or we install in our local system with some commands.

# root of the entire application is day4.js(file)

# npm:(does not stand for node package manager, just check official npm website)
It's a tool that comes with Node.js and helps you install, manage, and share JavaScript packages (libraries) — including React, Express, Lodash, etc.
in npm all packages are hosted we can directly using that command npm install.


# Yes, all essential details of your React (or any Node.js) project are stored in PACKAGE.JSON, and it guides npm on:

What to install
How to run your app
How to build it
What version to use
And even which tools are needed (like linters or testing libs)
PACKAGE.JSON is a configuration for npm



we have to pack all these project files into bundle before production, to do this there are libraries like webpack ,veet, parcel.

to install any dependency  COMMAND npm install dependency name

# there are two types of DEPENDENCIES:
1)dev dependency: these are required in a development phase.
2)normal dependency: these are also used in production phase.
(here parcel we to want use as dev dependency so we install using the command npm install -D parcel)

here in this line of dependencies{
    parcel:"^2.15.4"; here ^(CARET) symbol makes upgrade the version of that package automatically if any minor upgrades.
}

# PACKAGE-LOCK.JSON
it keeps track of the all exact versions of all the dependecies.

# NODE  MODULES:
these modules basically fetches all the code of our dependencies into our system.
here first i run command npm install -D parcel but the heavy folder like structure called nodemodules installed into our system because our project has a dependency called parcel , parcel has dependency of all those libraries.(which is called transistive dependency.)

if we go to nodemodules and see all libraries  in each library it has its own package.json(which contains dependencies to that package).

# .GITIGNORE
here we need not to push all these node modules to the github we can ignore these by adding this /node_modules  folder path to the .gitignore file.
it is mandatory to push package.json and package-lock.json to the github.Because if we have a package and package lock it us easy to regenerate nodemodules.
if nodemodules got deleted using the command NPM INSTALL(INSTALL ALL THE REQUIRED DEPENDENCIES SEEING PACKAGE AND PACKAGE-LOCK) we can reinstall.
there is no need to push files or folders which we can regenerate to github.


# NPX PARCEL INDEX.HTML
npx (executing a package)
with this command parcel(budler) build the source file index.html(with all the development we have done so far)  and host in server(local host port)

cdn links is not a good way to get react into our project.because we don't need to get react library from another network using cdn links its better to install node modeules(in which react is also hosted, we can install react AS PACKAGE in our system with command NPM INSTALL REACT).and the url of that cdn links may change its not a good way to proceed.

# WITHOUT CDN LINKS USING REACT INSTALLLING IT ON OUR SYSTEM WITH NPM:
here wherever we write react code we should 
import React from "react";(before importing we should install using NPM INSTALL REACT)
import { createRoot } from "react-dom/client";(HERE ALSO WE SHOULD INSTALL REACT-DOM)
and here we linked app.js(in which we have not written normal javascript and written react) in index.html as external js file and here as it is not browser jaavascript code we should include type="module" in script tag which is linked to external app.js file as 
<script type="module" src="./app.js"></script> this is correct.

# we have to remove 
main:"app.js"; line in package.json(BECAUSE IT DEFINES THE  ENTRY POINT TO OUR app which is not needed when exexuting eith parcel)
while executing using PARCEL with the below cmd
# NPX PARCEL INDEX.HTML(IN COMMAND WE SPECIFY THE ENTRY point like this index.html)
otherwise we will get error.


# PARCEL

when we make changes to any file in our build project ,in  host server where our file is running automatically refreshes because of this parcel module.
parcel creates or unique uses of parcel.
-Dev Build.
-Local Server(parcel includes a development server out of the box just run parcel index.html to get started)
-HMR -hot module replacement(refreshes the page automatically)
-File wathcing algorithm -written in c++
# parcel-cache folder (which is generated by deault stores compiled files or binary files which makes exectuiton faster next time)
-caching -Faster builds(makes it faster as there is a feature like cache memory for parcel , here in folder structure we can see (parcel-cache folder) where we can see binary files of all our project files which takes less time from second compilation with some changes.)
-Image optimization
-Minification(minifiles the entire one if we run production build)
-Bundling
-compressing(compressing the files before production).
-content hashing
-code splitting
-Differential bundling-support older browsers,firefox,mobile browsers(makes different bundles that support different browsers).
-Diagnostics(good error handling or beautiful error display)
-Error handling
-parcel gives also a way to host it on https server also,now we are seeing http server.
-Tree shaking-remove unused code
-different devlopment and production bundles.

# NPX PARCEL BUILD INDEX.HTML 
makes all our code files into prodution ready files (it will compress everything)
and the all production ready files are stored in (#DIST folder .
user@user:~/Desktop/react$ npx parcel build index.html
✨ Built in 336ms
dist/index.html                325 B    156ms
dist/react.5a240d73.css         67 B    164ms
dist/react.c8a5bce3.js     142.28 kB    405ms

# .gitignore
we can add
/dist
/.parcel-cache 
paths to this file because these two also can be regenerated like node modules.

# browserlist
browserlist":[
    "last 2 chrome version"
    "last 2 firefox version"
  ]
if we use browserlist in package.json like above, it supports the last 2 versions here.


# SCRIPTS

till now we opened our project in devloper mode(or executed) using the command NPX PARCEL INDEX.HTML but now by writting this is in package.json
"scripts":{
    "start":"parcel index.html"
    "build":"parcel build index.html"
    "test":"jest"
  }
# npm run start or npm start
we have replaced npx parcel  index.html with just npm start or npm run start.
we defined like we can use "start" keyword in the place of "parcel index.html" while executing "npm run start" this is enough, and in the same way "build","test" also.

# BABEL

IT IS A TRANSPLIER CONVERTS JSX TO JAVASCRIPT CODE AND JS CODE FROM ONE VERSION TO ANOTHER VERSIONS.

# IN JSX (LIKE HTML CODE WE USED TO CREATE REACT ELEMENTS)
WE WRITE LIKE THIS
const jsxheading = <h1 id="heading">created react element using jsx</h1>;
const jsxheading = <h1 id="heading" className="head">created react element using jsx</h1>;
here we use className in tag attribute not class.
in jsx  for attributes we have to use camelCase (first letter small and from then every word start letter capital)
if the jsx code is more than one line we have to wrap it in ()paranthesis(babel needs to understand start and end of the jsx)
jsx is embedded in < > or () in javascript code.

# REACT COMPONENTS
TWO TYPES:
CLASS BASED COMPONENET-OLD WAY
FUNCIONAL COMPONENT-NEW WAY(MOSTLY USED PRESENT)
this is a js function(it may be arrow function also) which returns a piece of jsx code.

this is how we render react elements
# root.render(element);
this is how we render react components
# root.render(<componentname/>) 
and while defining function (react component) its name should start with capital letter.

# component composititon
rendering and using one component in another component.


# differences between react element and react component
A React Element is a plain JavaScript object that describes what you want to render on the screen.

A React Component is a function or class that returns React elements.

React Elements are created using React.createElement() or JSX like <h1>Hello</h1>.

React Components are defined using functions or classes, such as function Welcome() { return <h1>Hello</h1>; }.

React Elements are static and do not contain any logic or state.

React Components can include logic, accept props, and manage state.

React Elements are the building blocks of the UI.

React Components are blueprints that generate elements dynamically.

A React Element represents a single UI node.

A React Component can return multiple elements and structure complex UIs.

React Elements are like snapshots of UI.

React Components are like reusable templates that generate those snapshots.

Let me know if you want code examples or analogies for these too!

# JSX
JSX protects against injection attacks by escaping any embedded JavaScript expressions before rendering them in the browser, so malicious code cannot be executed as HTML or script.

# wrapping more than one elements in single parent for jsx code
you do need one single parent wrapper around multiple JSX elements.

JSX must return only one parent element. So when you're returning multiple elements (like an <h1> and an <h3>), you must wrap them in something like in div tag or <>....</>.

# PROPS
like passing arguments to a function we pass props to react components.
passing data to component(to make it dynamic)

# food oredering app
/**
 * header
 *  -logo
 *  -nav items
 * body
 *  -search
 *  -restaurantcontainer
 *  -restaurantcard
 *      -image
 *      -name
 *      -star rating,nameof restaurant,cuisine,deliverytime
 * footer
 *  -copyright
 *  -links
 *  -address
 *  -contact
 */

# CONFIG DRIVEN UI
A Config-Driven UI is a design approach where the structure and behavior of the UI is controlled by a configuration object (usually JSON) instead of hardcoded JSX.

UI IS POWERED BY DATA.



# unique key
In React, when rendering a list of elements (like using .map()), each child must have a unique key prop. This is crucial for React’s reconciliation algorithm, which determines how to update the DOM efficiently.
In React, key is a special prop used to uniquely identify elements in a list.
Keys help React efficiently update and re-render only changed items.
Each sibling in a list must have a unique, stable key (like an ID).
Using index as a key is discouraged if the list can reorder or change.
Without proper keys, React may misbehave or show a warning in the console.



# why react
the everything we do in react can be done using normal html,css,javascript.
but the beauty of using a framework or library is its makes developers experience easy,its makes you write less code and do more on the web page, this is what major job of library or framework.

# the best practice
the best practice is breaking down to multiplefiles by making seperate files for seperate componeents.actually real world apps or websites have multiple components, we have to make it structured, its better to create different files for different components.

# file structure in react
the file strucure in react is upto the developers choice and convinience on how they want to structure their files, but its better to avoid too much nesting.here we created src, components folders.
it is better practice to name the file with exact component name if we define a component inside it.

# .js or .jsx 
anything we can use let us prefer .js extension for this js files.

# never
never ever keep hard coded data (example reslist,cdn link ofour app logo)into the app or components file directly ,keep them in utils or config.js.
WE CREATED UTILS FOLDER(WHICH IS LIKE UTILITIES THAT CAN BE USED ALL OVER ACROSS OUR PROJECT)

# map and filter functions in js
Exactly! In JavaScript, functions like map(), filter(), and reduce() are higher-order functions—they take another function as an argument. The function you pass is called a callback function.
Because JavaScript treats functions as first-class citizens—you can pass them around just like any other value (e.g., numbers, strings, arrays).
EXAMPLE FOR MAP FUNCTION:
{listOfRestaurants.map((restaurant)=>(
 <RestaurantCard key={restaurant.id} resData={restaurant}/>
))}
EXAMPLE FOR FILTER:
const filteredList=listOfRestaurants.filter(
(res)=>res.avgRating>4
);

In JavaScript, map() and filter() are methods of arrays. That means:

They are built-in functions that belong to the Array prototype, so you can call them on any array.



# there  are two types of exports, imports

-DEFAULT EXPORT/IMPORT

export default Component;
import Component from "path";

-NAMED EXPORT.IMPORT;(this is mainly used when we want to export more than one (element or component or variable etc) from a single file.)

export const Component=(props)=>{

}//like this while defining only we should preceed const keyword with export.

AND WHILE IMPORTING THIS TYPE OF EXPORTED ONE
import {Component} from "path"; here definitely we should specify component name as it is same as what we defined in the { } while importing.

# USE STATE
useState is a React Hook that lets function components have their own state (data that can change over time). It returns an array with two elements: the current state value and a function to update it. For example, const [count, setCount] = useState(0); creates a count variable initialized to 0, and setCount updates it. When setCount is called, React re-renders the component with the new value. Here's a simple example:
//USE STATE IS USED TO CREATE LOCAL STATE VARIABLES INSIDE  FUNCTIONAL COMPONENTS.
//NEVER CREATE USE STATE LOCAL VARIABLED IF ELSE CONDITIONS,FOR LOOPS ETC.

const [listOfRestaurants,setListOfRestaurants]=useState(reslist);#THIS IS NOTHING BUT ARRAY DESTRUTURING. 
WE CAN WRITE ABOVE THING LIKE BELOW ALSO:
                    const arr=useState(reslist);
                    const listOfRestaurants=arr[0];
                    const setListOfRestaurant=arr[1];
                    
THE CALLING OF THIS SETLISTOFRESTAURANTS() FUNCTION TRIGGERS THE REACT TO RERENDER THAT COMPONENT.(AND STORE IT AS VIRTUAL DOM)
HERE reslist is mockData.

<button className="filter-btn"
                onClick={()=>{
                    console.log("button clicked")
                    const filteredList=listOfRestaurants.filter(
                        (res)=>res.avgRating>4
                    );
                    setListOfRestaurants(filteredList);//we have to update that state variable 
                    console.log(listOfRestaurants);
                }}>Top Rated restaurants</button>
HERE ACCORDING TO THIS CODE OF BUTTON IF THAT  STATE VARIBALE(ListOfRestaurants) UPDATED THEN THE react will rerender the component in which that state variable is used, which updates the ui automatically once state variable updated.
<div className="res-container">
                {listOfRestaurants.map((restaurant)=>(
                  <RestaurantCard key={restaurant.id} resData={restaurant}/>
                ))}
            </div>

then here on frontend we get only  filtered restaurants of avgRating>4.
# //HERE WE JUST ON A BUTTON CLICK WE CHANGED THE UI OR FILTERD THE LIST OF RESTAURANTS(WITH VERY LESS CODE AND OPTIMIZED VERISON)
//OUR APP IS NOT FAST BECAUSE OF REACT,REACT IS ONLY GOOD AT DOM MANIPULATIONS(OR OPERATIONS).

# WHY REACT IS FAST
BECAUSE REACT IS DOING EFFICIENT DOM MANIPULATION , BECAUSE IT IS USING VIRTUAL DOM.

# VIRTUAL DOM
In React, the Virtual DOM (VDOM) is a virtual copy of the real DOM(hTML) kept in memory.
It helps React update the UI efficiently.
#
🔁 How It Works (Step-by-step):
Initial Render:
React creates a Virtual DOM tree from your JSX.

State/Props Change:
When your app's data changes (like state or props), React re-renders the Virtual DOM.
(REACT TRACKS THIS STATE VARIABLE(REACT KEEPS AN WYE ON THAT STATE VARIABLE)).

Diffing:
React compares the new Virtual DOM with the previous one (this is called "diffing").
FINDING THE DIFFERENCE BETWEEN TWO OBJECTS IS BETTER THAN TWO LONG HTML CODES.

Reconciliation:
React finds the minimal set of changes needed.

Real DOM Update:
React updates only those parts of the real DOM, instead of re-rendering everything.
WHICH MAKES IT FAST.

# REACT USES RECONCILIATION ALGORITHM(ALSO KNOWN AS REACT FIBRE)
Reconciliation is the process React uses to update the UI when your data (state/props) changes.

React creates a new Virtual DOM.

It compares it with the old Virtual DOM.

Then it finds what changed (using a diffing algorithm).

It updates only the changed parts in the real DOM.

📌 Goal: Make updates fast and efficient.


# monolithis vs microservice
# Monolithic Architecture:
A monolithic application is built as a single unified unit.
we have to develop entire application in any one language.

✅ Pros:
Simple to develop (at first) and deploy as one unit.

Easier debugging and testing – everything is in one place.

Good for small to medium-sized applications.



❌ Cons:
Hard to scale parts independently.

Tightly coupled – changes in one part can affect the entire app.

Slower development as the codebase grows.

Deployments become risky and time-consuming.

# microservice(this is the mmostly used one present)
A microservice application is built as a collection of small, independent services, each responsible for a specific feature.

✅ Pros:
Independent development and deployment of services.

Easier to scale services independently.

Fault isolation – one service can fail without crashing the whole app.

Better suited for large and complex systems.

here example:
we can have different teams for backend , authentication,forontend,database,and etc independently.
no need to use one particular project backend can use Golang,frontend can use react and like that.

❌ Cons:
More complex infrastructure (e.g., API gateways, service discovery).

Harder debugging and testing due to distributed nature.

Requires good inter-service communication design (usually via HTTP or messaging queues).

# ⚙️ 1. Load → Render → API → Render
🔄 Flow:
Page loads
UI is rendered immediately (with loading spinners or placeholders)
API call is made
UI re-renders with actual data

✅ Pros:
Faster perceived load time (user sees something immediately)
Can show skeleton screens or spinners
Good for client-side rendering (CSR)

❌ Cons:
May render twice, which can be inefficient
Initial UI may be empty or show loaders

💡 Used In:
Most React apps (CSR)
# use effect
SPAs using useEffect or similar hook


# ⚙️ 2. Load → API → Render
🔄 Flow:
Page loads
API is called before rendering
UI is rendered only once, with real data

✅ Pros:
No flickering or second render
More efficient — only one render
Good for server-side rendering (SSR) or static site generation (SSG)

❌ Cons:
Slower initial response
User may see blank screen longer (if no preloading)

💡 Used In:
Next.js SSR/SSG
Static HTML generated with data
Pre-rendering during build time

# react uses multiple render which makes it good.

# USE EFFECT
useEffect is a React Hook used to run side effects in function components — like fetching data from an API, setting up subscriptions, or updating the DOM.
SYNTAX:
useEffect(() => {
  // Your side effect logic here
}, [dependencies]);//this function is called automatically after that component in which this is used is renderd.

//if there is no dependency array=>useEffect is called on every render
//if dependency array is empty =[]=>useEffect is called on initial render(just once)
//if dependency array is [btnNamReact]=>called everytime btnNameReact is updated.

🔄 Behind the scenes:
Page loads.
useEffect does not run during the first render.
React renders <p>Loading users...</p>.(like something which is retuened in that function)
After render, useEffect triggers, fetches data from API.
setUsers(data) updates state → triggers re-render.(here we update statevariable using for example a function called setUsers()).
This time, React renders the list of users.

# shimmer ui
Shimmer UI (also called Skeleton Loading or Placeholder Loading) is a visual loading effect that mimics the layout of the final content using animated gray blocks or gradients. It's often used in web and mobile apps to show users that content is loading, giving the feel of faster performance and better UX.
before the actual data is rendered from api or any other source (that means in the time gap between of loading data from any api)

# filtering the restauarants with average rating>4(USE STATE IS USED)
# login button changes to logout when we click on that(HERE ALSO USE STATE IS USED)
# search bar for restaurants with restaurant name.(USE STATE IS USED)

# ROUTING
const appRouter=createBrowserRouter([
{
    path:"/",
    element:<AppLayout/>
},
{
    path:"/about",
    element:<About/>
}
])
//LIKE THIS WE CAN USE LIST OF PATHS AND WE CAN DEFINE THE ELEMENT I THAT PATH.

//whenever we try to access url or path which is not defined react will generate an 404 error found page which is predefined on its own.

# Hook (is nothing but a react function);#useRouterError
REact router dom gives us a specific react hook(useRouteError) to handle router error,
example usage:
import { useRouteError } from "react-router-dom";
const Error=()=>{
    const err=useRouteError();
    console.log(err);
    return (
        <div>
            <h1>OOPs!!</h1>
            <h2>Something went wrong</h2>
            <h3>{err.statusText}</h3>
        </div>
    );
};
export default Error;

# children routes
for example if we want header to stick when we navigate to different pages in the website , it is possible using children routes.
EXAMPLE:
const appRouter=createBrowserRouter([
{
    path:"/",
    element:<AppLayout />,
    children:[
        {
            path:"/",
            element:<Body/>,
        },
        {
            path:"/about",
            element:<About />,
        },
        {
            path:"/contact",
            element:<ContactUS/>
        },
    ],
    errorElement:<Error/>,
},
]);


# never use anchor tag(<a href="">) in react whenever you want to add links 
# link component
in react we have link component in react-router-dom
Single Page Applications (SPA):
SPAs load a single HTML page and dynamically update content using JavaScript, without full page reloads. This results in faster navigation and better user experience.(refreshes the components in the same page like changing the component also)

React Router <Link> Component:
Used for internal navigation in SPAs. It changes the URL without reloading the page, preserving the app state.
example:
<Link to="/about">About</Link>

HTML <a> Tag:
Causes a full page reload when clicked. Not ideal for SPAs because it breaks the dynamic behavior.
<a href="/about">About</a>
Key Difference:

<Link>: SPA-friendly, client-side routing.(REFRESHES THE COMPONENTS)

<a>: Traditional, triggers full reload.(RELOADS THE PAGE)

✅ Use <Link> from react-router-dom for internal links in Re



#  2 types of Routing in web apps
-Client side Routing
-Server side Routing

# CLINET SIDE ROUTING
IN REACT WE ARE BUILDING SINGLE PAGE APPLICATIONS (WHICH IS CLIENT SIDE ROUTING NO NEED OF NETWORK AGAIN ONCE THE MAIN PAGE IS LOADED (ALL ARE LOADED AT ONCE SO NO NEED OF NETWORK TO NAVIGATE ))
# IN REACT WE BUILD SINGLE PAGE APPLICATIONS (WHICH INCLUDES CLIENT SIDE ROUTING)

Client-Side Routing:
Handled by JavaScript in the browser (e.g., React Router).
Loads a single HTML page and updates content dynamically without full page reloads.
Faster navigation, better user experience.
Example: React, Angular, Vue apps.

Server-Side Routing:
Every URL change sends a request to the server.
Server returns a new HTML page for each route.
Slower navigation due to full page reloads.

Example: Traditional websites using PHP, Django, or Express with EJS.

🔁 Key Difference:

Client-side: Routes handled in browser.
Server-side: Routes handled on server.

# {useParams}
react hook which is used to get and store parameters passed in the url or path in a js variable.

# class base components
->We dont use now a days, but useful in interviews
->If we know this, we can easily understand the react functional components
->It is just a normal JS class
->class UserClass extends React.Component
->React class has a render method
->It is a class that which has some render which written some piece of jsx


# Life cycle of a parent child relationship
->About us page is parent component
->Useclasss is there in about us
->when about page starts rendering onto out web page, it starts rendering the JSX. It goes line by line and see userClass components, and it starts to load useClass now 
->Whenever the class is instantiated, the cosntructor is called
->After that, render is called
1)Parent constructor
2)Parent Render
  ->1)child Constructor
  ->2)child Render
  ->3)child ComponentDidMountain
3)Parent componenDidMountain


# componentDidMountain()
->componentDidMount() is a lifecycle method in React class-based components.
executed after render function is executed,this will be executed

# We don't make API calls in render() or return because:
render/return should be pure – no side effects like API calls.
They run every time the component re-renders, causing infinite loops.
API calls are asynchronous, but render needs synchronous output (JSX).
Calling APIs in render slows down UI and breaks React’s flow.
useEffect is the right place for side effects like fetching data.
#
API calls are side effects and should be handled in useEffect.
useEffect runs after the component renders, preventing repeated calls.
It ensures the API call runs only when needed (e.g., on mount).
The dependency array controls when the effect should re-run.
This keeps rendering and data fetching logic separate and clean.

# when i called multiple classes in single component 
# LIFE CYCLE WHEN THERE ARE MULTIPLE CHILDREN(REFER TO ABOUT.JS ONCE)
Parent constructor of that parent component.
Parent Render of that component.

    -Chusmalatha(class)child constructor of child component.
    -Chusmalatha(class)child render of child component.

    -Renusri(class)child constructor of child component.
    -Renusri(class)child render of child component.

  -Chusmalatha(class)child component Did Mount of child component.
  -Renusri(class)child component Did Mount of child component.

Parent Render of parent component.


# React Lifecycle: Two Main Phases
1. Render Phase(EVERYTHING HAPPENS IN VIRTUAL DOM)
🔸 What happens:
React calls the component function (or render() in class).
Prepares the UI (creates virtual DOM).
Does NOT touch the actual DOM yet.
It’s pure and synchronous.
FOR FUNCTIONS:(ORDER OF EXECUTION)
        RETURN()
FOR CLASS:(ORDER OF EXECUTION)
        CONSTRUCTOR()
        RENDER()

2. Commit Phase(MANIPULATES REAL DOM)
🔸 What happens:
React applies changes to the real DOM.
Runs side effects like useEffect, componentDidMount, etc.
Can schedule updates, DOM mutations, refs, etc.
FOR CLASS:(ORDER OF EXECUTION) IN THIS PHASE:-
        COMPONENTDIDMOUNT()
        COMPONENTDIDUPDATE()
FOR FUNCTIONS:(ORDER OF EXECUTION)
        USEEFFECT()

Render-->   Calculates what to show -->	JSX, virtual DOM.
Commit ->	Applies it to the real DOM --> Effects, refs, updates.

#
/**
 * 
 * --MOUNTING---
 * constructor(with dummy data)
 * Render(dummy)
 *    <HTML Dummy>
 * Component Did Mount
 *    <Api call>
 *    <this.setState>
 * 
 * --UPDATE--CYCLE
 * 
 *  render(API data)
 *  <HTML (new API data)>
 *   --Component Did Update
 * 
 * --UNMOUNTING CYCLE
 *   component Did Mount is called and then that component will be disappeared from DOM.
 *    FOR EXAMPLE: when we are in about us now and if we click on contact link in header then
 *    about us component will be unmounted and contact us component is mounted.
 */



# componentDidUpdate() is automatically called after setState() updates the state.
🔍 Here's the flow:
You call setState() ➝ this updates the state.
React re-runs the render() method.
After the DOM updates, React automatically calls componentDidUpdate().
componentDidUpdate() is the perfect place to perform actions after the UI reflects changes — like scrolling, focusing, fetching, syncing, etc.


# optimizing the code
# single responsibility principle
The Single Responsibility Principle (SRP) in React.js is a core design guideline derived from SOLID principles 
(used in object-oriented programming), which states:
A component should have only one reason to change.
In React terms, this means that each component should focus on one specific piece 
of functionality or responsibility. This improves readability, maintainability, testability, and reusability.

# creating a custom(user defined) hook(utility function)(used for particular usecase)
it's name is recommended to start with keyword use and we use this user defined hooks to make every component follow single responsbility principle. 
# in RestaurantMenu.js there are two responsibilities fetching data and then showcasing it in ui(to make it single responsible we have created useRestaurantMenu hook(in utils folder)  which takes restaurant id and returns data of that particular restaurant.)

# adding css there are 4 ways
1) normal css defining with classname
2) scss or sass
3) tailwind css
4) predefinrd libraries like chakra.ui,materialistic.ui,bootstrap like these contain the predefined styling for every component which we can directly use importing.

# tailwind css(consider this as primary css framework to make our application look good)exploring the tailwind css.(this is mostly used today  to make our app beautiful)
Tailwind utility classes directly inside your JSX or HTML—no external CSS files or inline styles needed.

# higher order component
A Higher Order Component (HOC) in React is a function that takes a component and returns a new component with enhanced behavior or additional props.
  # Use Cases
Reuse common logic (authentication, loading state, logging)
Add props or lifecycle methods
Modify rendering logic
Inject data (e.g., Redux connect() is a HOC)

# In accordion working(sharing the state between components)
showIndex is a state variable used to track which category accordion is currently open.
The state showIndex is declared in the parent component RestaurantMenu and passed down to each RestaurantCategory.
This is an example of lifting state up, where the parent manages state needed by multiple child components.
showItems is a boolean prop that checks if the current index matches showIndex to control visibility.
setShowIndex toggles the currently open accordion; if clicked again, it closes the category.
This approach ensures only one category is open at a time (controlled accordion behavior).
The component uses conditional rendering to display items only when showItems is true.
The logic enables clean and consistent UI state management for the accordion.

# props drilling
#


# user context
 What is UserContext in React?
UserContext is a React Context API pattern used to share data globally across components without having to pass props manually at every level (called "prop drilling").

🎯 When to Use Context?
Use Context when many components need access to the same data, such as:
Logged-in user info (UserContext)
Theme settings (ThemeContext)
Language settings (LocaleContext)

It includes two main parts:

Provider – Supplies the data
Consumer – Accesses the data

1. Provider: UserContext.Provider(refer to day4.js)
What it does:
Wraps around components to make data available to them.

Where to use it:
High up in the component tree (e.g., App.js or AppLayout.js)

2. Consumer: UserContext.Consumer or useContext(UserContext)
Reads context data inside components.
In class based components we use UserContext.Consumer component call.(refer about.js)
In React component we use useContext(UserContext) here useContext is a predefined hook.(refer to RestaurantCard.js)


# redux(A SEPERATE LIBRARY WHICH WE BASICALLY INSTALL IN OUR PROJECT)
(A PREDICTABLE STATE CONTAINER FOR JS APPS.)(REDUX IS LIKE A CENTRAL STORE FOR OUR APPS AND THAT STORE CONTAINS DIFFERENT SLICES)
REDUX IS NOT MANDATORY IN SMALL SCALE APPLICATIONS,
IT IS MAINLY USEFUL WHEN THERE ARE LOT OF READ AND WRITE OPERATIONS IN AN APPLICATION
AND IF THERE IS LOT OF DATA TO MANAGE IT IS GOOD TO USE.
# REDUX IS NOT THE ONLY LIBRARY WHICH IS USED TO MANAGE STATE.
WE HAVE SIMILAR LIBRARIES LIKE REDUX EXAMPLE: ZUSTAND.
AND THERE IS A LIBRARY REACT-REDUX TO BRIDGE THE GAP BETWEEN REACT AND REDUX.

# REDUX LIFE CYCLE IN SIMPLE POINTS:
1)User interacts with the app
(e.g., clicks a button, types text)
2)An action is dispatched
This is a message that describes what happened.
3)Reducer (FUNCTION) receives the action
It decides how to update the state based on the action type.
4)Reducer returns a new state
Old state is never changed directly — a new state is created.
5)Redux store is updated
The store now holds the new updated state.
6)UI components re-render
Components subscribed to that state will automatically update and reflect the changes.

# -install @reduxjs/toolkit and react-redux
    (NOW IN OUR APP)
  -Build our store
  -Connect our store to our app
  -Slice(cartSlice)
  -dispatch(action)
  -Selector

# different ones
onClick={()=>handleAddItem(item)}
onClick={handleAddItem}
onClick={handleAddItem(item)}


# Controlled Component (React controls the value)
The input value is stored in React state.
You use useState and update it with onChange
example:<input value={value} onChange={(e) => setValue(e.target.value)} />

# Uncontrolled Component (Browser controls the value)
The input value is stored in the DOM.
You use ref to get the value when needed.
Example:
<input ref={inputRef} />

Controlled = React controls the input
Uncontrolled = DOM controls the input



# Testing
# Developer testing
even a single line can mess up our code so testing is necessary.
TWO TYPES OF TESTING:
1)MANUAL TESTING
2)TESTING USING CODE

# TYPES OF TESTING (THAT DEVELOPER DO)
    -unit testing
    -Integration Testing
    -End to End Testing-e2e testing

#
for this there is a library called  # (REACT TESTING LIBRARY) this build top on DOM testing library. 
this react testing library also uses jest(seperate testing library).


(actually all these will be installed if we may have created this react app using create React app command).

# SETTING UP TESTING IN OUR APP:--

      we install testing library using command:-
      # npm i -D @testing-library/react
      #  npm i -D jest
      installing dependencies that are required for jest when we are using label.
      visit jest official website you will find there these all steps to set up jest when we are using babel.
      # npm install --save-dev babel-jest @babel/core @babel/preset-env
    
    BUT PARCEL ALREADY CONTAINS ITS OWN CONFIGURATION OF BABEL.NOW AS WE ADDED 
    BABEL.CONFIG.JS FILE (so there will be a conflict between parcel and babel ,
    this babel.congig.js overrides the existing babel configuration set by parcel.)

      #  so configure parcel config file to disable default babel transpilation\
      (here we added .parcelrc file)
      #check with npm run test
      #now jest configuration.(npx create-jest)
      #install jsdom(npm install --save-dev jest-environment-jsdom)
      #install @babel/preset-react with command(npm i -D @babel/preset-react) 
      //we need to install above one if we want to use jsx in test files.
      #include @babel/preset-react inside  babel config.

#  Why use jsdom in a testing environment?
jsdom is a JavaScript-based in-memory implementation of the browser's DOM and HTML standards, used in Node.js environments (like Jest). It simulates a web browser so you can run tests without needing a real browser.

#__tests__(__(2 underscores)=dunder method)
we write our test files in this folder.