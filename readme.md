# 
actually our browsers have javascript engine by default
but to run react we use cdn links or we install in our local system wi



# npm:(does not stand for node package manager, just check official npm website)
It's a tool that comes with Node.js and helps you install, manage, and share JavaScript packages (libraries) â€” including React, Express, Lodash, etc.
in npm all packages are hosted we can directly using that command npm install.


# Yes, all essential details of your React (or any Node.js) project are stored in PACKAGE.JSON, and it guides npm on:

What to install

How to run your app

How to build it

What version to use

And even which tools are needed (like linters or testing libs)

PACKAGE.JSON is a configuration for npm



we have to pack all these project files into bundle before production, to do this there are libraries like webpack ,veet, parcel.

to install any dependency  COMMAND npm install dependency name

# there are two types of DEPENDENCIES:
1)dev dependency: these are required in a development phase.
2)normal dependency: these are also used in production phase.
(here parcel we to want use as dev dependency so we install using the command npm install -D parcel)

here in this line of dependencies{
    parcel:"^2.15.4"; here ^(CARET) symbol makes upgrade the version of that package automatically if any minor upgrades.
}

# PACKAGE-LOCK.JSON
it keeps track of the all exact versions of all the dependecies.

# NODE  MODULES:
these modules basically fetches all the code of our dependencies into our system.
here first i run command npm install -D parcel but the heavy folder like structure called nodemodules installed into our system because our project has a dependency called parcel , parcel has dependency of all those libraries.(which is called transistive dependency.)

if we go to nodemodules and see all libraries  in each library it has its own package.json(which contains dependencies to that package).

# .GITIGNORE
here we need not to push all these node modules to the github we can ignore these by adding this /node_modules  folder path to the .gitignore file.
it is mandatory to push package.json and package-lock.json to the github.Because if we have a package and package lock it us easy to regenerate nodemodules.
if nodemodules got deleted using the command NPM INSTALL(INSTALL ALL THE REQUIRED DEPENDENCIES SEEING PACKAGE AND PACKAGE-LOCK) we can reinstall.
there is no need to push files or folders which we can regenerate to github.


# NPX PARCEL INDEX.HTML
npx (executing a package)
with this command parcel(budler) build the source file index.html(with all the development we have done so far)  and host in server(local host port)

cdn links is not a good way to get react into our project.because we don't need to get react library from another network using cdn links its better to install node modeules(in which react is also hosted, we can install react AS PACKAGE in our system with command NPM INSTALL REACT).and the url of that cdn links may change its not a good way to proceed.

# WITHOUT CDN LINKS USING REACT INSTALLLING IT ON OUR SYSTEM WITH NPM:
here wherever we write react code we should 
import React from "react";(before importing we should install using NPM INSTALL REACT)
import { createRoot } from "react-dom/client";(HERE ALSO WE SHOULD INSTALL REACT-DOM)
and here we linked app.js(in which we have not written normal javascript and written react) in index.html as external js file and here as it is not browser jaavascript code we should include type="module" in script tag which is linked to external app.js file as 
<script type="module" src="./app.js"></script> this is correct.

# we have to remove 
main:"app.js"; line in package.json(BECAUSE IT DEFINES THE  ENTRY POINT TO OUR app which is not needed when exexuting eith parcel)
while executing using PARCEL with the below cmd
# NPX PARCEL INDEX.HTML(IN COMMAND WE SPECIFY THE ENTRY point like this index.html)
otherwise we will get error.


# PARCEL

when we make changes to any file in our build project ,in  host server where our file is running automatically refreshes because of this parcel module.
parcel creates or unique uses of parcel
-Dev Build
-Local Server(parcel includes a development server out of the box just run parcel index.html to get started)
-HMR -hot module replacement(refreshes the page automatically)
-File wathcing algorithm -written in c++
# parcel-cache folder (which is generated by deault stores compiled files or binary files which makes exectuiton faster next time)
-caching -Faster builds(makes it faster as there is a feature like cache memory for parcel , here in folder structure we can see (parcel-cache folder) where we can see binary files of all our project files which takes less time from second compilation with some changes.)
-Image optimization
-Minification(minifiles the entire one if we run production build)
-Bundling
-compressing(compressing the files before production).
-content hashing
-code splitting
-Differential bundling-support older browsers,firefox,mobile browsers(makes different bundles that support different browsers).
-Diagnostics(good error handling or beautiful error display)
-Error handling
-parcel gives also a way to host it on https server also,now we are seeing http server.
-Tree shaking-remove unused code
-different devlopment and production bundles.

# NPX PARCEL BUILD INDEX.HTML 
makes all our code files into prodution ready files (it will compress everything)
and the all production ready files are stored in (#DIST folder .
user@user:~/Desktop/react$ npx parcel build index.html
âœ¨ Built in 336ms
dist/index.html                325 B    156ms
dist/react.5a240d73.css         67 B    164ms
dist/react.c8a5bce3.js     142.28 kB    405ms

# .gitignore
we can add
/dist
/.parcel-cache 
paths to this file because these two also can be regenerated like node modules.

# browserlist
browserlist":[
    "last 2 chrome version"
    "last 2 firefox version"
  ]
if we use browserlist in package.json like above, it supports the last 2 versions here.


# SCRIPTS

till now we opened our project in devloper mode(or executed) using the command NPX PARCEL INDEX.HTML but now by writting this is in package.json
"scripts":{
    "start":"parcel index.html"
    "build":"parcel build index.html"
    "test":"jest"
  }
# npm run start or npm start
we have replaced npx parcel  index.html with just npm start or npm run start.
we defined like we can use "start" keyword in the place of "parcel index.html" while executing "npm run start" this is enough, and in the same way "build","test" also.

# BABEL

IT IS A TRANSPLIER CONVERTS JSX TO JAVASCRIPT CODE AND JS CODE FROM ONE VERSION TO ANOTHER VERSIONS.

# IN JSX (LIKE HTML CODE WE USED TO CREATE REACT ELEMENTS)
WE WRITE LIKE THIS
const jsxheading = <h1 id="heading">created react element using jsx</h1>;
const jsxheading = <h1 id="heading" className="head">created react element using jsx</h1>;
here we use className in tag attribute not class.
in jsx  for attributes we have to use camelCase (first letter small and from then every word start letter capital)
if the jsx code is more than one line we have to wrap it in ()paranthesis(babel needs to understand start and end of the jsx)
jsx is embedded in < > or () in javascript code.

# REACT COMPONENTS
TWO TYPES:
CLASS BASED COMPONENET-OLD WAY
FUNCIONAL COMPONENT-NEW WAY(MOSTLY USED PRESENT)
this is a js function(it may be arrow function also) which returns a piece of jsx code.

this is how we render react elements
# root.render(element);
this is how we render react components
# root.render(<componentname/>) 
and while defining function (react component) its name should start with capital letter.

# component composititon
rendering and using one component in another component.


# differences between react element and react component
A React Element is a plain JavaScript object that describes what you want to render on the screen.

A React Component is a function or class that returns React elements.

React Elements are created using React.createElement() or JSX like <h1>Hello</h1>.

React Components are defined using functions or classes, such as function Welcome() { return <h1>Hello</h1>; }.

React Elements are static and do not contain any logic or state.

React Components can include logic, accept props, and manage state.

React Elements are the building blocks of the UI.

React Components are blueprints that generate elements dynamically.

A React Element represents a single UI node.

A React Component can return multiple elements and structure complex UIs.

React Elements are like snapshots of UI.

React Components are like reusable templates that generate those snapshots.

Let me know if you want code examples or analogies for these too!

# JSX
JSX protects against injection attacks by escaping any embedded JavaScript expressions before rendering them in the browser, so malicious code cannot be executed as HTML or script.

# wrapping more than one elements in single parent for jsx code
you do need one single parent wrapper around multiple JSX elements.

JSX must return only one parent element. So when you're returning multiple elements (like an <h1> and an <h3>), you must wrap them in something like in div tag or <>....</>.

# PROPS
like passing arguments to a function we pass props to react components.
passing data to component(to make it dynamic)

# food oredering app
/**
 * header
 *  -logo
 *  -nav items
 * body
 *  -search
 *  -restaurantcontainer
 *  -restaurantcard
 *      -image
 *      -name
 *      -star rating,nameof restaurant,cuisine,deliverytime
 * footer
 *  -copyright
 *  -links
 *  -address
 *  -contact
 */

# CONFIG DRIVEN UI
A Config-Driven UI is a design approach where the structure and behavior of the UI is controlled by a configuration object (usually JSON) instead of hardcoded JSX.

UI IS POWERED BY DATA.



# unique key
In React, when rendering a list of elements (like using .map()), each child must have a unique key prop. This is crucial for Reactâ€™s reconciliation algorithm, which determines how to update the DOM efficiently.
In React, key is a special prop used to uniquely identify elements in a list.
Keys help React efficiently update and re-render only changed items.
Each sibling in a list must have a unique, stable key (like an ID).
Using index as a key is discouraged if the list can reorder or change.
Without proper keys, React may misbehave or show a warning in the console.



# why react
the everything we do in react can be done using normal html,css,javascript.
but the beauty of using a framework or library is its makes developers experience easy,its makes you write less code and do more on the web page, this is what major job of library or framework.

# the best practice
the best practice is breaking down to multiplefiles by making seperate files for seperate componeents.actually real world apps or websites have multiple components, we have to make it structured, its better to create different files for different components.

# file structure in react
the file strucure in react is upto the developers choice and convinience on how they want to structure their files, but its better to avoid too much nesting.here we created src, components folders.
it is better practice to name the file with exact component name if we define a component inside it.

# .js or .jsx 
anything we can use let us prefer .js extension for this js files.

# never
never ever keep hard coded data (example reslist,cdn link ofour app logo)into the app or components file directly ,keep them in utils or config.js.
WE CREATED UTILS FOLDER(WHICH IS LIKE UTILITIES THAT CAN BE USED ALL OVER ACROSS OUR PROJECT)

# map and filter functions in js
Exactly! In JavaScript, functions like map(), filter(), and reduce() are higher-order functionsâ€”they take another function as an argument. The function you pass is called a callback function.
Because JavaScript treats functions as first-class citizensâ€”you can pass them around just like any other value (e.g., numbers, strings, arrays).
EXAMPLE FOR MAP FUNCTION:
{listOfRestaurants.map((restaurant)=>(
 <RestaurantCard key={restaurant.id} resData={restaurant}/>
))}
EXAMPLE FOR FILTER:
const filteredList=listOfRestaurants.filter(
(res)=>res.avgRating>4
);

In JavaScript, map() and filter() are methods of arrays. That means:

They are built-in functions that belong to the Array prototype, so you can call them on any array.



# there  are two types of exports, imports

-DEFAULT EXPORT/IMPORT

export default Component;
import Component from "path";

-NAMED EXPORT.IMPORT;(this is mainly used when we want to export more than one (element or component or variable etc) from a single file.)

export const Component=(props)=>{

}//like this while defining only we should preceed const keyword with export.

AND WHILE IMPORTING THIS TYPE OF EXPORTED ONE
import {Component} from "path"; here definitely we should specify component name as it is same as what we defined in the { } while importing.

# USE STATE
useState is a React Hook that lets function components have their own state (data that can change over time). It returns an array with two elements: the current state value and a function to update it. For example, const [count, setCount] = useState(0); creates a count variable initialized to 0, and setCount updates it. When setCount is called, React re-renders the component with the new value. Here's a simple example:

const [listOfRestaurants,setListOfRestaurants]=useState(reslist);#THIS IS NOTHING BUT ARRAY DESTRUTURING. 
WE CAN WRITE ABOVE THING LIKE BELOW ALSO:
                    const arr=useState(reslist);
                    const listOfRestaurants=arr[0];
                    const setListOfRestaurant=arr[1];
                    
THE CALLING OF THIS SETLISTOFRESTAURANTS() FUNCTION TRIGGERS THE REACT TO RERENDER THAT COMPONENT.(AND STORE IT AS VIRTUAL DOM)
HERE reslist is mockData.

<button className="filter-btn"
                onClick={()=>{
                    console.log("button clicked")
                    const filteredList=listOfRestaurants.filter(
                        (res)=>res.avgRating>4
                    );
                    setListOfRestaurants(filteredList);//we have to update that state variable 
                    console.log(listOfRestaurants);
                }}>Top Rated restaurants</button>
HERE ACCORDING TO THIS CODE OF BUTTON IF THAT  STATE VARIBALE(ListOfRestaurants) UPDATED THEN THE react will rerender the component in which that state variable is used, which updates the ui automatically once state variable updated.
<div className="res-container">
                {listOfRestaurants.map((restaurant)=>(
                  <RestaurantCard key={restaurant.id} resData={restaurant}/>
                ))}
            </div>

then here on frontend we get only  filtered restaurants of avgRating>4.
# //HERE WE JUST ON A BUTTON CLICK WE CHANGED THE UI OR FILTERD THE LIST OF RESTAURANTS(WITH VERY LESS CODE AND OPTIMIZED VERISON)
//OUR APP IS NOT FAST BECAUSE OF REACT,REACT IS ONLY GOOD AT DOM MANIPULATIONS(OR OPERATIONS).

# WHY REACT IS FAST
BECAUSE REACT IS DOING EFFICIENT DOM MANIPULATION , BECAUSE IT IS USING VIRTUAL DOM.

# VIRTUAL DOM
In React, the Virtual DOM (VDOM) is a virtual copy of the real DOM(hTML) kept in memory.
It helps React update the UI efficiently.
#
ðŸ” How It Works (Step-by-step):
Initial Render:
React creates a Virtual DOM tree from your JSX.

State/Props Change:
When your app's data changes (like state or props), React re-renders the Virtual DOM.
(REACT TRACKS THIS STATE VARIABLE(REACT KEEPS AN WYE ON THAT STATE VARIABLE)).

Diffing:
React compares the new Virtual DOM with the previous one (this is called "diffing").
FINDING THE DIFFERENCE BETWEEN TWO OBJECTS IS BETTER THAN TWO LONG HTML CODES.

Reconciliation:
React finds the minimal set of changes needed.

Real DOM Update:
React updates only those parts of the real DOM, instead of re-rendering everything.
WHICH MAKES IT FAST.

# REACT USES RECONCILIATION ALGORITHM(ALSO KNOWN AS REACT FIBRE)
Reconciliation is the process React uses to update the UI when your data (state/props) changes.

React creates a new Virtual DOM.

It compares it with the old Virtual DOM.

Then it finds what changed (using a diffing algorithm).

It updates only the changed parts in the real DOM.

ðŸ“Œ Goal: Make updates fast and efficient.


# monolithis vs microservice
# Monolithic Architecture:
A monolithic application is built as a single unified unit.
we have to develop entire application in any one language.

âœ… Pros:
Simple to develop (at first) and deploy as one unit.

Easier debugging and testing â€“ everything is in one place.

Good for small to medium-sized applications.



âŒ Cons:
Hard to scale parts independently.

Tightly coupled â€“ changes in one part can affect the entire app.

Slower development as the codebase grows.

Deployments become risky and time-consuming.

# microservice(this is the mmostly used one present)
A microservice application is built as a collection of small, independent services, each responsible for a specific feature.

âœ… Pros:
Independent development and deployment of services.

Easier to scale services independently.

Fault isolation â€“ one service can fail without crashing the whole app.

Better suited for large and complex systems.

here example:
we can have different teams for backend , authentication,forontend,database,and etc independently.
no need to use one particular project backend can use Golang,frontend can use react and like that.

âŒ Cons:
More complex infrastructure (e.g., API gateways, service discovery).

Harder debugging and testing due to distributed nature.

Requires good inter-service communication design (usually via HTTP or messaging queues).

# âš™ï¸ 1. Load â†’ Render â†’ API â†’ Render
ðŸ”„ Flow:
Page loads
UI is rendered immediately (with loading spinners or placeholders)
API call is made
UI re-renders with actual data

âœ… Pros:
Faster perceived load time (user sees something immediately)
Can show skeleton screens or spinners
Good for client-side rendering (CSR)

âŒ Cons:
May render twice, which can be inefficient
Initial UI may be empty or show loaders

ðŸ’¡ Used In:
Most React apps (CSR)
# use effect
SPAs using useEffect or similar hook


# âš™ï¸ 2. Load â†’ API â†’ Render
ðŸ”„ Flow:
Page loads
API is called before rendering
UI is rendered only once, with real data

âœ… Pros:
No flickering or second render
More efficient â€” only one render
Good for server-side rendering (SSR) or static site generation (SSG)

âŒ Cons:
Slower initial response
User may see blank screen longer (if no preloading)

ðŸ’¡ Used In:
Next.js SSR/SSG
Static HTML generated with data
Pre-rendering during build time

# react uses multiple render which makes it good.

# USE EFFECT
useEffect is a React Hook used to run side effects in function components â€” like fetching data from an API, setting up subscriptions, or updating the DOM.
SYNTAX:
useEffect(() => {
  // Your side effect logic here
}, [dependencies]);//this function is called automatically after that component in which this is used is renderd.

ðŸ”„ Behind the scenes:
Page loads.
useEffect does not run during the first render.
React renders <p>Loading users...</p>.(like something which is retuened in that function)
After render, useEffect triggers, fetches data from API.
setUsers(data) updates state â†’ triggers re-render.(here we update statevariable using for example a function called setUsers()).
This time, React renders the list of users.

# shimmer ui
Shimmer UI (also called Skeleton Loading or Placeholder Loading) is a visual loading effect that mimics the layout of the final content using animated gray blocks or gradients. It's often used in web and mobile apps to show users that content is loading, giving the feel of faster performance and better UX.
before the actual data is rendered from api or any other source (that means in the time gap between of loading data from any api)
